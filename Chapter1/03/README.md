# 03장 HTTP 메시지
배우게 될 내용들
- 메시지가 어떻게 흘러가는가
- HTTP 메시지의 세 부분(시작줄, 헤더, 개체 본문)
- 요청과 응답 메시지의 차이
- 요청 메시지가 반환하는 여러 상태 코드들
- 여러 HTTP 헤더들은 무슨 일을 하는가

## 3.1 메시지의 흐름
- HTTP 애플리케이션 간에 주고받은 데이터들의 블록은 메시지의 내용과 의미를 설명하는 메타 정보로 시작하고, 선택적으로 데이터가 올 수 있다.
- 이 메시지는 클라이언트, 서버, 프락시 사이를 흐른다.
- `인바운드`, `아웃바운드`, `업스트림`, `다운스트림`은 메시지의 방향을 의미하는 용어다.

  ### 3.1.1. 메시지는 원 서버 방향을 인바운드로 하여 송신된다
  - 트랜잭션 방향을 표현하기 위해 `인바운드`와 `아웃바운드`라는 용어를 사용한다.
  - 인바운드 : 메시지가 원 서버로 향하는 것 (서버 방향)
  - 아웃바운드 : 모든 처리가 끝난 뒤에 메시지가 사용자 에이전트로 돌아오는 것 (사용자 에이전트 방향)

  #### 🤔사용자 에이전트와 클라이언트의 차이가 뭘까?
  1. 사용자 에이전트 (User-Agent) </br>
  : 클라이언트(브라우저, 앱 등)가 서버와 통신할 때 자신을 식별하기 위해 보내는 문자열 또는 소프트웨어
  - 역할 : 서버가 어떤 장치 (PC, 모바일), 브라우저(Chrome, Firefox), 운영체제(Windows, macOS) 등에서 어떤 요청을 보냈는지 알 수 있도록 정보를 제공함
  ```plaintext
  User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/110.0.0.0 Safari/537.36
  ```
  - 사용처
    - 웹사이트에서 브라우저별 최적화된 콘텐츠 제공
    - 모바일과 데스크톱 버전 구분
    - 크롤링 및 봇 감지

  2. 클라이언트 (Client) </br>
  : 서버에 요청을 보내는 프로그램이나 장치
  - 역할 : 서버에 데이터를 요청하고, 서버의 응답을 받아서 처리하는 주체
  - 예제
    - 웹 브라우저 (Chrome, Edge, Safari 등)
    - 모바일 앱
    - API를 호출하는 프론트엔드 코드
    - 터미널에서 `curl` 같은 명령어 사용

  ### 3.1.2 다운스트림으로 흐르는 메시지
  모든 메시지는 다운스트림으로 흐른다.

## 3.2 메시지의 각 부분
HTTP 메시지는 단순한, 데이터의 구조화된 블록이다.
- 메시지는 시작줄, 헤더 블록, 본문으로 이루어져있다.
  - 시작줄 : 어떤 메시지인지 기술
  - 헤더 블록 : 속성
  - 본문 : 데이터 (없을 수도 있음)
- 시작줄과 헤더는 그냥 줄 단위로 분리된 아스키 문자열이다. 각 줄은 캐리지 리턴과 개행 문자로 구성된 두 글자의 줄바꿈 문자열로 끝난다.
  - 이 줄바꿈 문자열은 "CRLF"라고 쓴다.
  ### 3.2.1 메시지 문법
  모든 HTTP 메시지는 요청 메시지(Request)나 응답 메시지(Response)로 분류된다.

  ### 3.2.2 시작줄
  요청 메시지의 시작줄은 무엇을 해야 하는지 말해주고, 응답 메시지의 시작줄은 무슨 일이 일어났는지 말해준다.
  - 요청 시작줄 : 메서드 GET / POST / DELETE 등_ 어떻게 해줘
  - 응답 시작줄 : 200, 404, 503 등_어떻게 됐어

  ### 3.2.3 헤더
  ### 3.2.4 엔터티 본문
  ### 3.2.5 버전 0.9 메시지
  - HTTP 버전 정보가 나와있지 않음
  - 상태 코드나 사유 구절도 없고, 헤더도 없음
  => 지나치게 단순해서 다양한 상황에 대응할 수 없었다.

## 3.3 메서드
  ### 3.3.1 안전한 메서드 (Safe Method)
  GET과 HEAD 메서드는 안전하다고 할 수 있다.
  - 이 메서드의 HTTP 요청의 결과로 서버에 어떤 작용도 없기 때문

  ### 3.3.2 GET
  서버에게 리소스를 달라고 요청하기 위해 사용된다.
  
  ### 3.3.3 HEAD
  GET처럼 행동하지만, 서버는 응답으로 헤더만을 돌려준다. 이 메서드를 사용하면
  - 리소스를 가져오지 않고도 그에 대해 무엇인가(타입이라거나)를 알아낼 수 있다.
  - 응답의 상태 코드를 통해, 개체가 존재하는지 확인할 수 있다.
  - 헤더를 확인하여 리소스가 변경되었는지 검사할 수 있다.

  ### 3.3.4 PUT
  서버에 문서를 작성한다. 어떤 발행 시스템은 사용자가 PUT 요청을 이용해 웹 페이지를 만들고 웹 서버에 직접 게시할 수 있도록 해준다.
  - 서버가 Request의 본문을 가지고 요청 URL의 이름대로 새 문서를 만들거나, 이미 URL이 존재한다면 본문을 사용해서 교체하는 것
  - PUT은 콘텐츠를 변경할 수 있게 해주기 때문에 많은 웹 서버가 PUT을 수행하기 전에 사용자에게 비밀번호를 입력해서 로그인을 하도록 요구할 것이다.

  ### 3.3.5 POST
  서버에 입력 데이터를 전송하기 위해 설계되었다.
  - HTML 폼을 지원하기 위해 흔히 사용된다.
  - 채워진 폼에 담긴 데이터는 서버로 전송되며, 서버는 이를 모아서 필요로 하는 곳(그 데이터를 처리할 서버 게이트웨이 프로그램)

  ### 3.3.6 TRACE
  어떤 요청을 할때, 그 요청은 방화벽, 프락시, 게이트웨이 등의 애플리케이션을 통과할 수 있다.
  - 이들에게는 원래의 HTTP 요청을 수정할 수 있는 기회가 있다.
  - TRACE 메서드는 클라이언트에게 자신의 요청이 서버에 도달했을 때 어떻게 보이는지 알려준다.
  - 목적지 서버에서 '루프백(loopback)' 진단을 시작한다. 요청 전송의 마지막 단계에 있는 서버는 자신이 받은 요청 메시지를 본문에 넣어 TRACE 응답을 되돌려준다.
  - TRACE는 진단을 위해 사용할 때는 괜찮지만, 그 대신 중간 애플리케이션이 여러 다른 종류의 요청(GET, HEAD, POST 등 각각 다른 메서드를 사용한)들을 일관되게 다룬다고 가정하는 문제가 있다.
    - 프락시는 POST 요청을 바로 서버로 통과시키는 반면, GET 요청은 웹 캐시와 같은 다른 HTTP 애플리케이션으로 전송한다.
    - TRACE 메서드를 구별하는 메커니즘을 제공하지 않는다.
  
  ### 3.3.7 OPTIONS
  웹 서버에게 여러 가지 종류의 지원 범위에 대해 물어본다. 
  - 서버에게 특정 리소스에 대해 어떤 메서드가 지원되는지 물어볼 수 있다. (몇몇 서버는 특정 종류의 객체에 대해 특정 동작만을 지원한다.)

  ### 3.3.8 DELETE
  서버에게 요청한 URL로 지정한 리소스를 삭제할 것을 요청한다. 그러나 클라이언트는 삭제가 수행되는 것을 보장하지 못한다. 왜냐하면 HTTP 명세는 서버가 클라이언트에게 알리지 않고 요청을 무시하는 것을 허용하기 때문이다.

  ### 3.3.9 확장 메서드
  |메서드|설명|
  |---|---|
  |LOCK|사용자가 리소스를 잠글 수 있게 해준다. 예를 들어, 문서를 편집하는 동안 다른 사람이 동시에 같은 문서를 편집하지 못하도록 문서를 잠글 수 있다.|
  |MKCOL|사용자가 문서를 생성할 수 있게 해준다.|
  |COPY|서버에 있는 리소스를 복사한다|
  |MOVE|서버에 있는 리소스를 옮긴다|

## 3.4 상태 코드
상태코드는 클라이언트에게 그들의 트랜잭션을 이해할 수 있는 쉬운 방법을 제공한다.

| 상태 코드 | 사유 구절 | 의미 |
|------------|----|-----|
|100 | Continue|요청의 시작 부분 일부가 받아들여졌으며, 클라이언트는 나머지를 계속 이어서 보내야 함을 의미한다. 이것을 보낸 후, 서버는 반드시 요청을 받아 응답해야 한다. 더 자세한 정보는 부록 C의 Expect 헤더를 보라|
|101 | Switching Protocols|클라이언트가 Upgrade 헤더에 나열한 것 중 하나로 서버가 프로토콜을 바꾸었음을 의미한다.|

  ### 3.4.2 200-299: 성공 상태 코드
  | 상태 코드 | 사유 구절 | 의미 |
  |----------|-----------|-----|
  |200 | OK | 요청은 정상이고, 엔터티 본문은 요청된 리소스를 포함하고 있다. |
  | 201 | Created | 서버 개체를 생성하라는 요청(예 : PUT)을 위한 것. 응답은 생성된 리소스에 대한 최대한 구체적인 참조가 담긴 Location헤더와 함께 그 리소스를 참조할 수 있는 여러 URL을 엔터티 본문에 포함해야 한다. 서버는 상태 코드를 보내기에 앞서 반드시 객체를 생성해야 한다 |
  | 202 | Accepted | 요청은 받아들여졌으나 서버는 아직 그에 대한 어떤 동작도 수행하지 않았다. 서버가 요청의 처리를 완료할 것인지에 대한 그 어떤 보장도 없다. 이것은 단지 요청이 받아들이기에 적법해보인다는 의미일 뿐이다. 서버는 엔터티 본문에 요청에 대한 상태와 가급적이면 요청의 처리가 언제 완료될 것인지에 대한 추정(혹은 그에 대한 정보를 어디서 얻을 수 있는지도) 포함해야 한다.
  | 203 | Non-Authoritative Information | 엔터티 헤더(자세한 설명은 "엔터티 헤더"를 보라)에 들어있는 정보가 원래 서버가 아닌 리소스의 사본에서 왔다. 중개자가 리소스의 사본을 갖고 있었지만 리소스에 대한 메타 정보(헤더)를 검증하지 못한(혹은 안한)경우 이런 일이 발생할 수 있다. 이 응답코드는 필수적으로 사용되어야 하는 것은 아니다. 이것은 엔터티 헤더가 원래 서버에서 온 것이었다면 응답이 200 상태였을 애플리케이션을 위한 선택사항이다.|
  | 204 | No Content | 응답 메시지는 헤더와 상태줄을 포함하지만 엔터티 본문은 포함하지 않는다. 주로 웹 브라우저를 새 문서로 이동시키지 않고 갱신하고자 할 때 (예 : 폼을 리프레시)  사용한다. |
  | 205 | Reset Content | 주로 브라우저를 위해 사용되는 또 하나의 코드. 브라우저에게 현재 페이지에 있는 HTML 폼에 채워진 모든 값을 비우라고 말한다. |
  | 206 |  Partial Content |  부분 혹은 범위 요청이 성공했다. 나중에 우리는 클라이언트가 특별한 헤더를 사용해서 문서의 특정 부분 혹은 특정 범위를 요청할 수 있다는 것을 보게 될 것이다. </br> 이 상태코드는 범위 요청이 성공했음을 의미한다. Range 헤더에 대해 더 자세한 것은 15장의 '범위요청'을 보라. </br> 206 응답은 Content-Rage와 Date 헤더를 반드시 포함해야 하며, Etag와 Content-Location 중 하나의 헤더도 반드시 포함해야 한다.|

  ### 3.4.3 300-399 : 리다이렉션 상태 코드
  리다이렉션 상태 코드는 클라이언트가 관심있어 하는 리소스에 대해 다른 위치를 사용하라고 말해주거나 그리소스의 내용 대신 다른 대안 응답을 제공한다.
  | 상태 코드 | 사유 구절 | 의미 |
  |----------|-----------|------|
  | 300 | Multiple Choices | 클라이언트가 동시에 여러 리소스를 가리키는 URL을 요청한 경우, 그 리소스의 목록과 함께 반환한다. 사용자는 목록에서 원하는 하나를 선택할 수 있다. 어떤 서버가 하나의 HTML 문서를 영어와 프랑스어 모두로 제고하는 경우 등에 사용할 수 있을 것이다. 이와 같이 여러 버전이 존재할 때의 클라이언트 협상에 대해서는 17장을 보라. 서버는 Location 헤더에 선호하는 URL을 포함시킬 수 있다. |
  | 301 | Moved Permanently | 요청한 URL이 옮겨졌을 때 사용한다. 응답은 Location 헤더에 현재 리소스가 존재하고 있는 URL을 포함해야 한다. |
  | 302 | Found | 301 상태 코드와 같다. 그러나 클라이언트는 Location 헤더로 주어진 URL을 리소스를 임시로 가리키기 위한 목적으로 사용해야 한다. 이후의 요청에서는 원래 URL을 사용해야 한다. |
  | 303 | See Other | 클라이언트에게 리소스를 다른 URL에서 가져와야 한다고 말해주고자 할 때 쓰인다. 새 URL은 응답 메시지의 Location 헤더에 들어있다. 이 상태 코드의 주 목적은 POST 요청에 대한 응답으로 클라이언트에게 리소스의 위치를 알려주는 것이다. |
  |304 | Not Modified | 클라이언트 헤더를 이용해 조건부 요청을 만들 수 있다. 조건부 헤더에 대해서는 표 3-15를 보라. 만약 클라이언트가 GET과 같은 조건부 요청을 보냈고 그 요청한 리소스가 최근에 수정된 일이 없다면, 이 코드는 리소스가 수정되지 않았음을 의미하게 된다. 이 상태 코드를 동반한 응답은 엔터티 본문을 가져서는 안된다. |
  | 305 | Use Proxy | 리소스가 반드시 프락시를 통해서 접근되어야 함을 나타내기 위해 사용한다. 프락시의 위치는 Location 헤더를 통해 주어진다. 클라이언트는 이 응답을 특정 리소스에 대한 것이라고만 해석한다. 클라이언트는 모든 요청에 대해 이 프락시를 통해야 한다고 상정하지 않으며, 그 리소스를 갖고 있는 서버에 대한 요청이라 할지라도 마찬가지다. 이 점은 중요하다. 프락시가 요청에 잘못 간섭한다면 이는 오동작을 유발할 수 있고, 보안 문제를 일으킬 수 있다. |
  ...

  ... // 현재 변경된 개념과 상태 코드 등이 많은 것으로 판단되어 생략하도록 하겠습니다.